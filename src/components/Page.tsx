/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";
import { useGraph, useLoader } from "@react-three/fiber";
function wrapText(context:any, text:string, x:number, y:number, maxWidth:number, fontSize:number, fontFace:string){
  var words = text.split(' ');
  var line = '';
  var lineHeight=fontSize;

  context.font = fontSize + "px " + fontFace;

  for(var n = 0; n < words.length; n++) {
    var testLine = line + words[n] + ' ';
    var metrics = context.measureText(testLine);
    var testWidth = metrics.width;
    if(testWidth > maxWidth) {
      context.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    }
    else {
      line = testLine;
    }
  }
  context.fillText(line, x, y);
  return(y);
}

type GLTFResult = GLTF & {
  nodes: {
    Cube004: THREE.Mesh
    Cube004_1: THREE.Mesh
    Bone: THREE.Bone
  }
  materials: {
    recto: THREE.MeshStandardMaterial
    Verso: THREE.MeshStandardMaterial
  }
}

type ActionName = 'LivreOpen' | 'PageTurn' | 'Carnet Shape key.001'
type GLTFActions = Record<ActionName, THREE.AnimationAction>
type Props = JSX.IntrinsicElements["group"] & {
  image?:string;
  title?:string;
  description?:string;
  turned?:boolean;
  onStart:()=>void;
  onEnd:(i:boolean)=>void;
  focus:boolean;
}
export function Page(props: Props) {
  const [, forceUpdate] = useReducer(x => x + 1, 0);
  const [turned,setTurned]= useState(props.turned===true)
  const onFinish = useCallback(() => { props.onEnd(!turned) }, [turned])
  const group = useRef<any>();
  const { scene, materials, animations } = useGLTF("/3dModels/page3.glb") as GLTFResult;

const {actions, mixer} = useAnimations(animations, group);
const speed = 1.8
const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])
const linegap=100;
const pageColor = "#FFBE89" ;
const lineColor = "#E58647";
const [imgLoaded, setImgLoaded] = useState(false);
const {nodes} = useGraph(clone) as any
const timer = useRef()
const canvasRecto :HTMLCanvasElement = useMemo(() => {

  const canvasTemp = document.createElement("canvas");
  const size = 1000
  canvasTemp.width = size
  canvasTemp.height = size * 1.41
  const ctx = canvasTemp.getContext('2d')
  if(ctx) {
    ctx.fillStyle = pageColor;
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 15;
    ctx.fillRect(0, 0, canvasTemp.width, canvasTemp.height);
    ctx.fill();
    ctx.beginPath();
     for (let i = 0; i*linegap <canvasTemp.height; i++) {
      ctx.moveTo(0, i*linegap);
      ctx.lineTo(canvasTemp.width, i*linegap);
      ctx.stroke();
     }
     if(props.image){
      const image = document.createElement("img")
      image.src = props.image;
      image.onload=()=>{
        setImgLoaded(true)
      }
      ctx.drawImage(image, canvasTemp.width*0.1, canvasTemp.width*0.1,canvasTemp.width*0.8,canvasTemp.height*0.8)
      // ctx.drawImage(image, dx, dy, dWidth, dHeight)
    }
  }
  return canvasTemp
}, [imgLoaded])

const canvasVerso = useMemo(() => {
  const canvasTemp = document.createElement("canvas");
  const size = 1000
  canvasTemp.width = size
  canvasTemp.height = size * 1.41
  const ctx = canvasTemp.getContext('2d')
  if(ctx) {
    ctx.fillStyle = pageColor;
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 15;
    
    ctx.fillRect(0, 0, canvasTemp.width, canvasTemp.height);
    ctx.fill();
    ctx.beginPath();
     for (let i = 0; i*linegap <canvasTemp.height; i++) {
      ctx.moveTo(0, i*linegap);
      ctx.lineTo(canvasTemp.width, i*linegap);
      ctx.stroke();
     }
      ctx.textAlign = 'center'
     ctx.fillStyle = 'Black'
    props.description &&  wrapText(ctx,props.description,canvasTemp.width*0.5, canvasTemp.height*0.5,canvasTemp.width*0.8,50,"Baby Doll")
    props.title &&  wrapText(ctx,props.title,canvasTemp.width*0.5, canvasTemp.height*0.2,canvasTemp.width*0.8,100,"Baby Doll")

  }
  return canvasTemp
}, [])

useEffect(()=>{
    nodes.Cube004_1.material =new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvasRecto)})
    nodes.Cube004.material = new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvasVerso)})

})

useEffect(()=>{
  if(actions.PageTurn){
   actions.PageTurn.clampWhenFinished =true
   actions.PageTurn.enabled=true
   actions.PageTurn.setLoop(THREE.LoopOnce,0)
   actions.PageTurn.time = turned? 0:actions.PageTurn.getClip().duration;   
    actions.PageTurn.setEffectiveTimeScale(0);
    actions.PageTurn.play()
    actions.PageTurn.paused=true
  }
  
 },[])
const turning=()=>{
  if(actions.PageTurn){
    actions.PageTurn.setEffectiveTimeScale(turned?speed:-speed);
       if(!actions.PageTurn.isRunning()){
        setTimeout(()=>props.onStart(),100)
         
         actions.PageTurn.reset()
         actions.PageTurn.time = turned? 0:actions.PageTurn.getClip().duration; 
       }

      actions.PageTurn.play()
      setTurned(!turned)

      clearTimeout(timer.current)
      //@ts-ignore
      timer.current = setTimeout(()=>{

        onFinish()
      },
      (turned?
        actions.PageTurn.getClip().duration-actions.PageTurn.time:
        actions.PageTurn.time
      )/speed*0.95*1000)
    }

}
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Page" onClick={(e)=>{ if(props.focus){ e.stopPropagation();  turning()}  }}>
          
            <primitive object={nodes.Bone}  />
          
          
          {/* <mesh> */}
              {/* <boxGeometry/>
              <Canvas/>
          </mesh> */}
        </group>
      </group>
    </group>
    
  );
}

useGLTF.preload("/3dModels/page3.glb");

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/






